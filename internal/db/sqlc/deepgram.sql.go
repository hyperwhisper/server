// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deepgram.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const countActiveUserAPIKeys = `-- name: CountActiveUserAPIKeys :one
SELECT COUNT(*) FROM api_keys WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) CountActiveUserAPIKeys(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveUserAPIKeys, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllAPIKeys = `-- name: CountAllAPIKeys :one
SELECT COUNT(*) FROM api_keys
`

func (q *Queries) CountAllAPIKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllAPIKeys)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllTranscriptionLogs = `-- name: CountAllTranscriptionLogs :one
SELECT COUNT(*) FROM transcription_logs
`

func (q *Queries) CountAllTranscriptionLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllTranscriptionLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserAPIKeys = `-- name: CountUserAPIKeys :one
SELECT COUNT(*) FROM api_keys WHERE user_id = $1
`

func (q *Queries) CountUserAPIKeys(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserAPIKeys, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserTranscriptionLogs = `-- name: CountUserTranscriptionLogs :one
SELECT COUNT(*) FROM transcription_logs WHERE user_id = $1
`

func (q *Queries) CountUserTranscriptionLogs(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserTranscriptionLogs, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one

INSERT INTO api_keys (user_id, key_hash, key_prefix, name)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, key_hash, key_prefix, name, created_at, last_used_at, revoked_at
`

type CreateAPIKeyParams struct {
	UserID    uuid.UUID
	KeyHash   string
	KeyPrefix string
	Name      string
}

// =====================
// API KEY QUERIES
// =====================
func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createAPIKey,
		arg.UserID,
		arg.KeyHash,
		arg.KeyPrefix,
		arg.Name,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.RevokedAt,
	)
	return i, err
}

const createTranscriptionLog = `-- name: CreateTranscriptionLog :one

INSERT INTO transcription_logs (user_id, api_key_id, deepgram_params, client_ip)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, api_key_id, started_at, ended_at, duration_seconds, status, error_message, deepgram_params, bytes_sent, client_ip
`

type CreateTranscriptionLogParams struct {
	UserID         uuid.UUID
	ApiKeyID       uuid.UUID
	DeepgramParams json.RawMessage
	ClientIp       sql.NullString
}

// =====================
// TRANSCRIPTION LOG QUERIES
// =====================
func (q *Queries) CreateTranscriptionLog(ctx context.Context, arg CreateTranscriptionLogParams) (TranscriptionLog, error) {
	row := q.db.QueryRowContext(ctx, createTranscriptionLog,
		arg.UserID,
		arg.ApiKeyID,
		arg.DeepgramParams,
		arg.ClientIp,
	)
	var i TranscriptionLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ApiKeyID,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.Status,
		&i.ErrorMessage,
		&i.DeepgramParams,
		&i.BytesSent,
		&i.ClientIp,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE id = $1 AND user_id = $2
`

type DeleteAPIKeyParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteAPIKey(ctx context.Context, arg DeleteAPIKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteAPIKey, arg.ID, arg.UserID)
	return err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT id, user_id, key_hash, key_prefix, name, created_at, last_used_at, revoked_at FROM api_keys WHERE key_hash = $1 AND revoked_at IS NULL
`

func (q *Queries) GetAPIKeyByHash(ctx context.Context, keyHash string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByHash, keyHash)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.RevokedAt,
	)
	return i, err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, user_id, key_hash, key_prefix, name, created_at, last_used_at, revoked_at FROM api_keys WHERE id = $1
`

func (q *Queries) GetAPIKeyByID(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.Name,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.RevokedAt,
	)
	return i, err
}

const getSystemUsageSummary = `-- name: GetSystemUsageSummary :one
SELECT
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(*) as total_sessions,
    COALESCE(SUM(duration_seconds), 0)::DECIMAL(12,3) as total_duration_seconds,
    COALESCE(SUM(bytes_sent), 0) as total_bytes_sent
FROM transcription_logs
WHERE started_at >= $1 AND started_at < $2
`

type GetSystemUsageSummaryParams struct {
	StartDate time.Time
	EndDate   time.Time
}

type GetSystemUsageSummaryRow struct {
	UniqueUsers          int64
	TotalSessions        int64
	TotalDurationSeconds string
	TotalBytesSent       interface{}
}

func (q *Queries) GetSystemUsageSummary(ctx context.Context, arg GetSystemUsageSummaryParams) (GetSystemUsageSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getSystemUsageSummary, arg.StartDate, arg.EndDate)
	var i GetSystemUsageSummaryRow
	err := row.Scan(
		&i.UniqueUsers,
		&i.TotalSessions,
		&i.TotalDurationSeconds,
		&i.TotalBytesSent,
	)
	return i, err
}

const getTranscriptionLog = `-- name: GetTranscriptionLog :one
SELECT id, user_id, api_key_id, started_at, ended_at, duration_seconds, status, error_message, deepgram_params, bytes_sent, client_ip FROM transcription_logs WHERE id = $1
`

func (q *Queries) GetTranscriptionLog(ctx context.Context, id uuid.UUID) (TranscriptionLog, error) {
	row := q.db.QueryRowContext(ctx, getTranscriptionLog, id)
	var i TranscriptionLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ApiKeyID,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.Status,
		&i.ErrorMessage,
		&i.DeepgramParams,
		&i.BytesSent,
		&i.ClientIp,
	)
	return i, err
}

const getUserUsageSummary = `-- name: GetUserUsageSummary :one
SELECT
    COUNT(*) as total_sessions,
    COALESCE(SUM(duration_seconds), 0)::DECIMAL(12,3) as total_duration_seconds,
    COALESCE(SUM(bytes_sent), 0) as total_bytes_sent
FROM transcription_logs
WHERE user_id = $1 AND started_at >= $2 AND started_at < $3
`

type GetUserUsageSummaryParams struct {
	UserID    uuid.UUID
	StartDate time.Time
	EndDate   time.Time
}

type GetUserUsageSummaryRow struct {
	TotalSessions        int64
	TotalDurationSeconds string
	TotalBytesSent       interface{}
}

func (q *Queries) GetUserUsageSummary(ctx context.Context, arg GetUserUsageSummaryParams) (GetUserUsageSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getUserUsageSummary, arg.UserID, arg.StartDate, arg.EndDate)
	var i GetUserUsageSummaryRow
	err := row.Scan(&i.TotalSessions, &i.TotalDurationSeconds, &i.TotalBytesSent)
	return i, err
}

const getUserUsageSummaryByStatus = `-- name: GetUserUsageSummaryByStatus :many
SELECT
    status,
    COUNT(*) as count,
    COALESCE(SUM(duration_seconds), 0)::DECIMAL(12,3) as total_duration_seconds
FROM transcription_logs
WHERE user_id = $1 AND started_at >= $2 AND started_at < $3
GROUP BY status
`

type GetUserUsageSummaryByStatusParams struct {
	UserID    uuid.UUID
	StartDate time.Time
	EndDate   time.Time
}

type GetUserUsageSummaryByStatusRow struct {
	Status               string
	Count                int64
	TotalDurationSeconds string
}

func (q *Queries) GetUserUsageSummaryByStatus(ctx context.Context, arg GetUserUsageSummaryByStatusParams) ([]GetUserUsageSummaryByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserUsageSummaryByStatus, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserUsageSummaryByStatusRow
	for rows.Next() {
		var i GetUserUsageSummaryByStatusRow
		if err := rows.Scan(&i.Status, &i.Count, &i.TotalDurationSeconds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllAPIKeys = `-- name: ListAllAPIKeys :many
SELECT ak.id, ak.user_id, ak.key_hash, ak.key_prefix, ak.name, ak.created_at, ak.last_used_at, ak.revoked_at, u.username, u.email
FROM api_keys ak
JOIN users u ON ak.user_id = u.id
ORDER BY ak.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllAPIKeysParams struct {
	Limit  int32
	Offset int32
}

type ListAllAPIKeysRow struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	KeyHash    string
	KeyPrefix  string
	Name       string
	CreatedAt  sql.NullTime
	LastUsedAt sql.NullTime
	RevokedAt  sql.NullTime
	Username   string
	Email      string
}

func (q *Queries) ListAllAPIKeys(ctx context.Context, arg ListAllAPIKeysParams) ([]ListAllAPIKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllAPIKeys, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllAPIKeysRow
	for rows.Next() {
		var i ListAllAPIKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyHash,
			&i.KeyPrefix,
			&i.Name,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.RevokedAt,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTranscriptionLogs = `-- name: ListAllTranscriptionLogs :many

SELECT tl.id, tl.user_id, tl.api_key_id, tl.started_at, tl.ended_at, tl.duration_seconds, tl.status, tl.error_message, tl.deepgram_params, tl.bytes_sent, tl.client_ip, u.username, u.email, ak.name as api_key_name
FROM transcription_logs tl
JOIN users u ON tl.user_id = u.id
JOIN api_keys ak ON tl.api_key_id = ak.id
ORDER BY tl.started_at DESC
LIMIT $1 OFFSET $2
`

type ListAllTranscriptionLogsParams struct {
	Limit  int32
	Offset int32
}

type ListAllTranscriptionLogsRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	ApiKeyID        uuid.UUID
	StartedAt       time.Time
	EndedAt         sql.NullTime
	DurationSeconds sql.NullString
	Status          string
	ErrorMessage    sql.NullString
	DeepgramParams  json.RawMessage
	BytesSent       int64
	ClientIp        sql.NullString
	Username        string
	Email           string
	ApiKeyName      string
}

// =====================
// ADMIN QUERIES
// =====================
func (q *Queries) ListAllTranscriptionLogs(ctx context.Context, arg ListAllTranscriptionLogsParams) ([]ListAllTranscriptionLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllTranscriptionLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllTranscriptionLogsRow
	for rows.Next() {
		var i ListAllTranscriptionLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ApiKeyID,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.Status,
			&i.ErrorMessage,
			&i.DeepgramParams,
			&i.BytesSent,
			&i.ClientIp,
			&i.Username,
			&i.Email,
			&i.ApiKeyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAPIKeys = `-- name: ListUserAPIKeys :many
SELECT id, user_id, key_hash, key_prefix, name, created_at, last_used_at, revoked_at FROM api_keys WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListUserAPIKeysParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) ListUserAPIKeys(ctx context.Context, arg ListUserAPIKeysParams) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, listUserAPIKeys, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyHash,
			&i.KeyPrefix,
			&i.Name,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTranscriptionLogs = `-- name: ListUserTranscriptionLogs :many
SELECT id, user_id, api_key_id, started_at, ended_at, duration_seconds, status, error_message, deepgram_params, bytes_sent, client_ip FROM transcription_logs WHERE user_id = $1 ORDER BY started_at DESC LIMIT $2 OFFSET $3
`

type ListUserTranscriptionLogsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) ListUserTranscriptionLogs(ctx context.Context, arg ListUserTranscriptionLogsParams) ([]TranscriptionLog, error) {
	rows, err := q.db.QueryContext(ctx, listUserTranscriptionLogs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TranscriptionLog
	for rows.Next() {
		var i TranscriptionLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ApiKeyID,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.Status,
			&i.ErrorMessage,
			&i.DeepgramParams,
			&i.BytesSent,
			&i.ClientIp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIKey = `-- name: RevokeAPIKey :exec
UPDATE api_keys SET revoked_at = NOW() WHERE id = $1 AND user_id = $2
`

type RevokeAPIKeyParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) RevokeAPIKey(ctx context.Context, arg RevokeAPIKeyParams) error {
	_, err := q.db.ExecContext(ctx, revokeAPIKey, arg.ID, arg.UserID)
	return err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys SET last_used_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyLastUsed, id)
	return err
}

const updateTranscriptionLogComplete = `-- name: UpdateTranscriptionLogComplete :exec
UPDATE transcription_logs
SET ended_at = NOW(),
    duration_seconds = $2,
    status = 'completed',
    bytes_sent = $3
WHERE id = $1
`

type UpdateTranscriptionLogCompleteParams struct {
	ID              uuid.UUID
	DurationSeconds sql.NullString
	BytesSent       int64
}

func (q *Queries) UpdateTranscriptionLogComplete(ctx context.Context, arg UpdateTranscriptionLogCompleteParams) error {
	_, err := q.db.ExecContext(ctx, updateTranscriptionLogComplete, arg.ID, arg.DurationSeconds, arg.BytesSent)
	return err
}

const updateTranscriptionLogError = `-- name: UpdateTranscriptionLogError :exec
UPDATE transcription_logs
SET ended_at = NOW(),
    status = 'error',
    error_message = $2,
    bytes_sent = $3
WHERE id = $1
`

type UpdateTranscriptionLogErrorParams struct {
	ID           uuid.UUID
	ErrorMessage sql.NullString
	BytesSent    int64
}

func (q *Queries) UpdateTranscriptionLogError(ctx context.Context, arg UpdateTranscriptionLogErrorParams) error {
	_, err := q.db.ExecContext(ctx, updateTranscriptionLogError, arg.ID, arg.ErrorMessage, arg.BytesSent)
	return err
}

const updateTranscriptionLogTimeout = `-- name: UpdateTranscriptionLogTimeout :exec
UPDATE transcription_logs
SET ended_at = NOW(),
    status = 'timeout',
    bytes_sent = $2
WHERE id = $1
`

type UpdateTranscriptionLogTimeoutParams struct {
	ID        uuid.UUID
	BytesSent int64
}

func (q *Queries) UpdateTranscriptionLogTimeout(ctx context.Context, arg UpdateTranscriptionLogTimeoutParams) error {
	_, err := q.db.ExecContext(ctx, updateTranscriptionLogTimeout, arg.ID, arg.BytesSent)
	return err
}
